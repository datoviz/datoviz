/*************************************************************************************************/
/*  Axes                                                                                         */
/*************************************************************************************************/


/*************************************************************************************************/
/*  Includes                                                                                     */
/*************************************************************************************************/

#include "scene/axes.h"
#include "_macros.h"
#include "scene/axis.h"
#include "scene/labels.h"
#include "scene/scene.h"
#include "scene/ticks.h"
#include "scene/transform.h"
#include "scene/viewset.h"
#include "scene/visuals.h"
#include "scene/visuals/glyph.h"



/*************************************************************************************************/
/*  Constants                                                                                    */
/*************************************************************************************************/

// TODO: customizable parameters
#define DVZ_AXES_FONT_SIZE          24
#define DVZ_AXES_DEFAULT_TICK_COUNT 8



/*************************************************************************************************/
/*  Util functions                                                                               */
/*************************************************************************************************/

static void axis_common_params(DvzAxis* axis)
{
    float font_size = DVZ_AXES_FONT_SIZE;

    cvec4 color_glyph = {0, 0, 0, 255};
    cvec4 color_lim = {0, 0, 0, 255};
    cvec4 color_grid = {0, 0, 0, 255};
    cvec4 color_major = {0, 0, 0, 255};
    cvec4 color_minor = {0, 0, 0, 255};

    float width_lim = 4;
    float width_grid = 2;
    float width_major = 4;
    float width_minor = 2;

    float length_lim = 1;
    float length_grid = 1;
    float length_major = 40;
    float length_minor = 20;

    dvz_axis_size(axis, font_size);
    dvz_axis_width(axis, width_lim, width_grid, width_major, width_minor);
    dvz_axis_length(axis, length_lim, length_grid, length_major, length_minor);
    dvz_axis_color(axis, color_glyph, color_lim, color_grid, color_major, color_minor);

    dvz_glyph_bgcolor(axis->glyph, (vec4){1, 1, 1, 1});
}

static void axis_horizontal_params(DvzAxis* axis)
{
    ANN(axis);

    vec2 hanchor = {+.5, 0};
    vec2 hoffset = {0, -80};

    dvz_axis_anchor(axis, hanchor);
    dvz_axis_offset(axis, hoffset);

    float a = 1.0;
    vec3 p0 = {-a, -a, 0};
    vec3 p1 = {+a, -a, 0};
    vec3 p2 = {-a, +a, 0};
    vec3 p3 = {+a, +a, 0};

    dvz_axis_pos(axis, p0, p1, p2, p3);

    dvz_visual_fixed(axis->glyph, false, true, false);
    dvz_visual_fixed(axis->segment, false, true, false);

    dvz_visual_clip(axis->glyph, DVZ_VIEWPORT_CLIP_BOTTOM);
    dvz_visual_clip(axis->segment, DVZ_VIEWPORT_CLIP_BOTTOM);
}

static void axis_vertical_params(DvzAxis* axis)
{
    ANN(axis);

    vec2 vanchor = {+1, 0};
    vec2 voffset = {-50, -10};

    dvz_axis_anchor(axis, vanchor);
    dvz_axis_offset(axis, voffset);

    float a = 1.0;
    vec3 p0 = {-a, -a, 0};
    vec3 p1 = {-a, +a, 0};
    vec3 p2 = {+a, -a, 0};
    vec3 p3 = {+a, +a, 0};

    dvz_axis_pos(axis, p0, p1, p2, p3);

    dvz_visual_fixed(axis->glyph, true, false, false);
    dvz_visual_fixed(axis->segment, true, false, false);

    dvz_visual_clip(axis->glyph, DVZ_VIEWPORT_CLIP_LEFT);
    dvz_visual_clip(axis->segment, DVZ_VIEWPORT_CLIP_LEFT);
}

static bool axis_labels(
    DvzAxis* axis, DvzTicks* ticks, DvzLabels* labels, //
    double dmin, double dmax, uint32_t requested_count)
{
    ANN(labels);
    ANN(axis);

    double lmin = 0, lmax = 0, lstep = 0;

    // Calculate the tick positions.
    bool has_changed = dvz_ticks_compute(ticks, dmin, dmax, requested_count);

    // Skip if the ticks have not changed.
    if (!has_changed)
        return false;

    log_info("ticks have changed, updating tick visual");

    // Get the calculated number of ticks and lmin, lmax, lstep.
    uint32_t tick_count = dvz_ticks_range(ticks, &lmin, &lmax, &lstep);

    // Get the calculated format.
    // DvzTicksFormat format = dvz_ticks_format(ticks); // NOTE: unused for now

    // NOTE: disabled for now.
    uint32_t precision = 2;
    int32_t exponent = 0;
    double offset = 0.0;

    // Generate the tick labels.
    uint32_t glyph_count = dvz_labels_generate(
        labels, DVZ_TICKS_FORMAT_DECIMAL, precision, exponent, offset, lmin, lmax, lstep);

    // Obtain the arrays generated by the labels.
    char* string_labels = dvz_labels_string(labels);
    uint32_t* index = dvz_labels_index(labels);
    uint32_t* length = dvz_labels_length(labels);
    double* values = dvz_labels_values(labels);

    // Replace the concatenation of null-terminated strings by space-terminated strings,
    // to call freetype only once.
    uint32_t buffer_size = glyph_count + tick_count; // all glyphs + 1 space per glyph
    char* glyphs = (char*)calloc(buffer_size, sizeof(char));
    memcpy(glyphs, string_labels, buffer_size);
    // Replace the null termination by a space, except for the last group.
    uint32_t idx = 0;
    for (uint32_t i = 1; i < tick_count; i++)
    {
        idx = index[i];
        ASSERT(idx >= 1);
        idx--;
        // This character should be a null termination.
        ASSERT(glyphs[idx] == 0);
        // We replace it by a space.
        glyphs[idx] = ' ';
    }
    // char* exponent = dvz_labels_exponent(labels); // NOTE: unused for now
    // char* offset = dvz_labels_offset(labels); // NOTE: unused for now

    // // DEBUG.
    // dvz_labels_print(labels);
    // printf("glyphs:\n");
    // for (uint32_t i = 0; i < buffer_size; i++)
    // {
    //     printf("%d %c | ", glyphs[i], glyphs[i]);
    // }
    // printf("\nindex:\n");
    // for (uint32_t i = 0; i < tick_count; i++)
    // {
    //     printf("%d ", index[i]);
    // }
    // printf("\nlength %d:\n", tick_count);
    // for (uint32_t i = 0; i < tick_count; i++)
    // {
    //     printf("%d ", length[i]);
    // }
    // printf("\nvalues:\n");
    // for (uint32_t i = 0; i < tick_count; i++)
    // {
    //     printf("%f ", values[i]);
    // }

    dvz_axis_set(axis, tick_count, values, glyph_count, glyphs, index, length);

    FREE(glyphs);

    return true;
}

static bool set_axis(DvzAxes* axes, DvzTicksFlags which, double dmin, double dmax)
{
    ANN(axes);

    bool horizontal = which == DVZ_TICKS_HORIZONTAL;

    DvzAxis* axis = horizontal ? axes->xaxis : axes->yaxis;
    DvzTicks* ticks = horizontal ? axes->xticks : axes->yticks;
    DvzLabels* labels = horizontal ? axes->xlabels : axes->ylabels;

    dvz_axis_range(axis, dmin, dmax);

    // TODO: dependent on viewport size?
    uint32_t requested_count = DVZ_AXES_DEFAULT_TICK_COUNT;
    return axis_labels(axis, ticks, labels, dmin, dmax, requested_count);
}



/*************************************************************************************************/
/*  Axes functions                                                                               */
/*************************************************************************************************/

DvzAxes* dvz_axes(DvzPanel* panel, int flags)
{
    ANN(panel);
    ANN(panel->figure);
    ANN(panel->figure->scene);

    DvzBatch* batch = panel->figure->scene->batch;
    ANN(batch);

    DvzAxes* axes = (DvzAxes*)calloc(1, sizeof(DvzAxes));
    axes->panel = panel;
    axes->flags = flags;

    // Axis visuals.
    axes->xaxis = dvz_axis(batch, flags); // NOTE: axes flags passed to axis visual flags
    axes->yaxis = dvz_axis(batch, flags);

    // Ticks.
    axes->xticks = dvz_ticks(0);
    axes->yticks = dvz_ticks(0);

    // Labels.
    axes->xlabels = dvz_labels();
    axes->ylabels = dvz_labels();

    // Set the viewport size.
    dvz_axes_resize(axes);

    // Common parameters.
    axis_common_params(axes->xaxis);
    axis_common_params(axes->yaxis);

    // Axis-specific parameters.
    axis_horizontal_params(axes->xaxis);
    axis_vertical_params(axes->yaxis);

    // Initial.
    set_axis(axes, DVZ_TICKS_HORIZONTAL, -1, 1);
    set_axis(axes, DVZ_TICKS_VERTICAL, -1, 1);

    // TODO: margins.
    dvz_panel_margins(panel, 20, 20, 120, 120);
    dvz_axis_panel(axes->xaxis, panel);
    dvz_axis_panel(axes->yaxis, panel);

    return axes;
}



void dvz_axes_xref(DvzAxes* axes, dvec2 range)
{
    ANN(axes);
    // TODO
    // set the reference range corresponding to MVP id
}



void dvz_axes_yref(DvzAxes* axes, dvec2 range)
{
    ANN(axes);
    // TODO
    // set the reference range corresponding to MVP id
}



void dvz_axes_xset(DvzAxes* axes, dvec2 range)
{
    ANN(axes);
    // TODO
    // set the MVP so that the visible range is the one specified, given the ref
}



void dvz_axes_xget(DvzAxes* axes, dvec2 range)
{
    ANN(axes);
    ANN(axes->panel);

    DvzMVP* mvp = dvz_transform_mvp(axes->panel->transform);
    dvz_axis_get(axes->xaxis, mvp, range);
}



void dvz_axes_yget(DvzAxes* axes, dvec2 range)
{
    ANN(axes);
    ANN(axes->panel);

    DvzMVP* mvp = dvz_transform_mvp(axes->panel->transform);
    dvz_axis_get(axes->yaxis, mvp, range);
}



void dvz_axes_yset(DvzAxes* axes, dvec2 range)
{
    ANN(axes);
    // TODO
    // set the MVP so that the visible range is the one specified, given the ref
}



void dvz_axes_resize(DvzAxes* axes)
{
    // Size is given in framebuffer pixels.

    ANN(axes);

    DvzPanel* panel = axes->panel;
    ANN(panel);

    DvzView* view = panel->view;
    ANN(view);

    dvz_ticks_size(axes->xticks, view->shape[0], DVZ_AXES_FONT_SIZE);
    dvz_ticks_size(axes->yticks, view->shape[1], DVZ_AXES_FONT_SIZE);
}



void dvz_axes_update(DvzAxes* axes)
{
    ANN(axes);

    // Compute the currently visible range.
    dvec2 xrange = {0};
    dvec2 yrange = {0};

    dvz_axes_xget(axes, xrange);
    dvz_axes_yget(axes, yrange);

    // Use the current viewport size in the axes before the computation of the ticks.
    dvz_axes_resize(axes);

    // Compute the ticks and update the visuals if the ticks have changed.
    set_axis(axes, DVZ_TICKS_HORIZONTAL, xrange[0], xrange[1]);
    set_axis(axes, DVZ_TICKS_VERTICAL, yrange[0], yrange[1]);
}



void dvz_axes_destroy(DvzAxes* axes)
{
    ANN(axes);

    if (axes->xaxis)
        dvz_axis_destroy(axes->xaxis);
    if (axes->yaxis)
        dvz_axis_destroy(axes->yaxis);

    if (axes->xticks)
        dvz_ticks_destroy(axes->xticks);
    if (axes->yticks)
        dvz_ticks_destroy(axes->yticks);

    if (axes->xlabels)
        dvz_labels_destroy(axes->xlabels);
    if (axes->ylabels)
        dvz_labels_destroy(axes->ylabels);

    FREE(axes);
}
